rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isHost(roomId) {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/rooms/$(roomId)/participants/$(request.auth.uid)) &&
        (get(/databases/$(database)/documents/rooms/$(roomId)/participants/$(request.auth.uid)).data.role == 'host' ||
         get(/databases/$(database)/documents/rooms/$(roomId)/participants/$(request.auth.uid)).data.role == 'cohost');
    }
    
    function isParticipant(roomId) {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/rooms/$(roomId)/participants/$(request.auth.uid));
    }
    
    function roomNotEnded(roomId) {
      return get(/databases/$(database)/documents/rooms/$(roomId)).data.status != 'ended';
    }
    
    // Rooms collection
    match /rooms/{roomId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.createdBy;
      allow update: if isHost(roomId);
      allow delete: if isHost(roomId);
      
      // Participants subcollection
      match /participants/{participantId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated() && request.auth.uid == request.resource.data.uid;
        allow update: if isHost(roomId) || (isAuthenticated() && request.auth.uid == resource.data.uid);
        allow delete: if isHost(roomId);
      }
      
            // Chat subcollection
      match /chat/{msgId} {
        allow read: if isAuthenticated();
        allow create: if isAuthenticated() &&
          (request.auth.uid == request.resource.data.uid || request.resource.data.isSystemMessage == true);
        allow update: if false; // Chat messages cannot be edited
        allow delete: if isAuthenticated() && 
          (isHost(roomId) || request.auth.uid == resource.data.uid); // Allow host or message owner to delete
      }
      
      // Private Messages subcollection - only sender and receiver can access
      match /privateMessages/{msgId} {
        // ✅ CRITICAL FIX: Allow read if user is sender or receiver, even if no longer a participant
        // This ensures users can see their messages in inbox even after leaving/ending room
        // IMPORTANT: This rule allows reading messages even if user is not currently a participant
        // For collection queries with WHERE clauses, Firestore evaluates the query first, then checks this rule
        // The WHERE clauses (senderId == user.uid OR receiverId == user.uid) ensure only user's messages are queried
        allow read: if isAuthenticated() && 
          (request.auth.uid == resource.data.senderId || request.auth.uid == resource.data.receiverId);
        allow create: if isAuthenticated() && 
          request.auth.uid == request.resource.data.senderId &&
          request.resource.data.senderId != request.resource.data.receiverId && // Prevent self-messages
          isParticipant(roomId); // Must be a participant in the room
        // Allow update for: receiver marking as read, sender/receiver adding themselves to deletedBy, or sender/receiver updating files array
        allow update: if isAuthenticated() && 
          ((request.auth.uid == resource.data.receiverId && 
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read'])) || // Receiver can mark as read
           ((request.auth.uid == resource.data.senderId || request.auth.uid == resource.data.receiverId) && 
            (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['deletedBy']) || // Sender or receiver can add to deletedBy
             request.resource.data.diff(resource.data).affectedKeys().hasOnly(['files']) || // Sender or receiver can update files array
             request.resource.data.diff(resource.data).affectedKeys().hasOnly(['deletedBy', 'files'])))); // Or both
        allow delete: if isAuthenticated() && 
          (request.auth.uid == resource.data.senderId || request.auth.uid == resource.data.receiverId);
      }
      
      // Notifications subcollection
      match /notifications/{notificationId} {
        allow read: if isAuthenticated() && isParticipant(roomId);
        allow create: if isHost(roomId); // Only hosts can create notifications
        allow update: if isAuthenticated() && request.auth.uid == resource.data.participantId; // Participants can mark their own notifications as read
        allow delete: if isHost(roomId);
      }
    }
    
    // Invites collection
    match /invites/{inviteId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == resource.data.createdBy;
      allow update: if isAuthenticated() && request.auth.uid == resource.data.createdBy;
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.createdBy;
    }
    
    // Scheduled meetings collection
    match /meetings/{meetingId} {
      allow read: if isAuthenticated() && request.auth.uid == resource.data.ownerUid;
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.ownerUid;
      allow update: if isAuthenticated() && request.auth.uid == resource.data.ownerUid;
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.ownerUid;
      
      // Logs subcollection - read-only for meeting owners
      match /logs/{logId} {
        allow read: if isAuthenticated() && 
          request.auth.uid == get(/databases/$(database)/documents/meetings/$(meetingId)).data.ownerUid;
        allow create: if false; // Only functions can create logs
        allow update, delete: if false; // Logs are immutable
      }
    }
    
    // Recordings collection
    match /recordings/{recId} {
      allow read: if isAuthenticated() && 
        exists(/databases/$(database)/documents/rooms/$(resource.data.roomId)/participants/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/rooms/$(resource.data.roomId)/participants/$(request.auth.uid)).data.role == 'host';
      allow create: if isAuthenticated(); // Only functions can create recordings
      allow update, delete: if false; // Recordings are immutable
    }
    
        // Helper function to check if user is admin
    function isAdmin() {
      return isAuthenticated() && 
        exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['admin', 'superadmin'];
    }
    
    // Users collection - CRITICAL for user authentication and profiles
    match /users/{userId} {
      allow read: if isAuthenticated(); // Allow reading all users for admin checking       
      allow create: if isAuthenticated() && request.auth.uid == userId;
      // Allow users to update their own profile OR admins to update any user (for role assignment)
      allow update: if isAuthenticated() && 
        (request.auth.uid == userId || isAdmin());
      allow delete: if false; // Users cannot delete their own profiles
      
      // Deleted messages subcollection - per-user message deletion tracking
      match /deletedMessages/{roomId} {
        allow read: if isAuthenticated() && request.auth.uid == userId;
        allow create: if isAuthenticated() && request.auth.uid == userId;
        allow update: if isAuthenticated() && request.auth.uid == userId;
        allow delete: if isAuthenticated() && request.auth.uid == userId;
      }
      
      // Meeting views subcollection - track opened meetings and last seen message counts
      match /meetingViews/{roomId} {
        allow read: if isAuthenticated() && request.auth.uid == userId;
        allow create: if isAuthenticated() && request.auth.uid == userId;
        allow update: if isAuthenticated() && request.auth.uid == userId;
        allow delete: if isAuthenticated() && request.auth.uid == userId;
      }
      
      // Settings subcollection - user preferences and settings
      match /settings/{settingId} {
        allow read: if isAuthenticated() && request.auth.uid == userId;
        allow create: if isAuthenticated() && request.auth.uid == userId;
        allow update: if isAuthenticated() && request.auth.uid == userId;
        allow delete: if isAuthenticated() && request.auth.uid == userId;
      }
      
      // Events subcollection - imported calendar events
      match /events/{eventId} {
        allow read: if isAuthenticated() && request.auth.uid == userId;
        allow create: if isAuthenticated() && request.auth.uid == userId;
        allow update: if isAuthenticated() && request.auth.uid == userId;
        allow delete: if isAuthenticated() && request.auth.uid == userId;
      }
    }
    
    // User uploads collection - for file storage metadata
    match /userUploads/{uploadId} {
      allow read: if isAuthenticated() && request.auth.uid == resource.data.userId;
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.userId;
      allow update: if isAuthenticated() && request.auth.uid == resource.data.userId;
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.userId;
    }
    
    // Default media collection - available to all authenticated users
    match /defaultMedia/{mediaId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated(); // Allow any authenticated user to create (for first admin setup)
      allow update: if isAuthenticated() && (request.auth.uid == resource.data.uploadedBy || isAdmin());
      // Allow deletion if: user uploaded it OR user is admin OR uploadedBy is empty/missing (hardcoded defaults)
      allow delete: if isAuthenticated() && 
        (request.auth.uid == resource.data.uploadedBy || 
         isAdmin() || 
         !resource.data.uploadedBy || 
         resource.data.uploadedBy == '');
    }
    
    // Active meetings collection - track one meeting per user at a time
    match /activeMeetings/{userId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == userId;
      allow update: if isAuthenticated() && request.auth.uid == userId;
      allow delete: if isAuthenticated() && request.auth.uid == userId;
    }
    
    // ✅ CRITICAL: User feedback metadata collection - for 24-hour cooldown tracking
    match /userFeedbackMeta/{userId} {
      allow read: if isAuthenticated() && request.auth.uid == userId;
      allow create: if isAuthenticated() && request.auth.uid == userId;
      allow update: if isAuthenticated() && request.auth.uid == userId;
      allow delete: if false; // Prevent deletion
    }
    
    // ✅ CRITICAL: Meeting feedback collection - stores user feedback about meetings
    match /meetingFeedback/{feedbackId} {
      // Users can read their own feedback
      allow read: if isAuthenticated() && 
        (request.auth.uid == resource.data.participantUserId || isAdmin());
      // Users can create feedback for meetings they participated in
      allow create: if isAuthenticated() && 
        request.auth.uid == request.resource.data.participantUserId;
      // Only admins can update/delete feedback
      allow update, delete: if isAdmin();
    }
    
    // Subscription Plans collection - editable only by admins, readable by all authenticated users
    match /subscriptionPlans/{planId} {
      // All authenticated users can read plan configs (needed for subscription checks)
      allow read: if isAuthenticated();
      // Only admins can create/update/delete plan configs
      allow create, update, delete: if isAdmin();
    }
  }
}

